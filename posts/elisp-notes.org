#+BEGIN_COMMENT
.. title: Elsip 笔记
.. slug: elisp-notes
.. date: 2014-1-05 00:36:49 +0800
.. tags: emacs, elisp
.. link: 
.. description: 
.. type: text
#+END_COMMENT

#+HTML: <!-- TEASER_END -->

#+TITLE: elisp学习
* Display
** Faces
*** Defining Faces
 -- Macro: defface face spec doc [keyword value]
 SPEC 应该是一个关联表 `(DISPLAY ATTS)'
 DISPLAY 可能是`default' `t' 形如`(CHARACTERISTIC VALUE...)的列表，ATTS是一系列属性值
 `(CHARACTERISTIC VALUE...)' CHARACTERISTIC可能值有`type'(graphic,x,pc,w32,tty[[windows-system]] `class'(color,grayscale,mono') `background'(light, dark) `mincolors' `surpports'
下面是face `region'的定义
#+BEGIN_SRC lisp -n
     (defface region
       '((((class color) (min-colors 88) (background dark))
          :background "blue3")
         (((class color) (min-colors 88) (background light))
          :background "lightgoldenrod2")
         (((class color) (min-colors 16) (background dark))
          :background "blue3")
         (((class color) (min-colors 16) (background light))
          :background "lightgoldenrod2")
         (((class color) (min-colors 8))
          :background "blue" :foreground "white")
         (((type tty) (class mono))
          :inverse-video t)
         (t :background "gray"))
       "Basic face for highlighting the region."
       :group 'basic-faces)
#+END_SRC
*** Face Attributes
    See [[Displaying Faces]] 
    `:family'[[Fontsets]] `:foundry' `:width' `:height' `:weight' `:slant'
    `:forground' `:background' `:underline' `:overline'
    `:strike-through' `:box'(nil, t, COLOR) `:inverse-video'
    `:stipple' `:font' `:inherit'
    - Function: font-family-list &optional frame
    - User Option: underline-minimum-offset
    - User Option: x-bitmap-file-path
    - Function: bitmap-spec-p object 
*** Attribute Functions
    + Function: set-face-attribute face frame &rest arguments
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'foo nil
                    :width 'extended
                    :weight 'bold
                    :underline "red")
;;  FRAME 为 t 的话，则新建的frame 应用该属性
#+END_SRC
    + Function: face-attribute face attribute &optional frame inherit ::返回ATTRIBUTE的值
    + Function: set-face-foreground face color &optional frame 
    + Function: set-face-background face color &optional frame
    + Function: set-face-stipple
    + Function: set-face-font
    + Function: set-face-underline-p face underline &optional frame
    + ...

*** Displaying Faces
*** Face Remapping
*** Face Functions
    + Function: make-face name
    + Function: face-list :: 返回已定义的face 
*** Auto Faces
*** Font Lookup
*** Fontsets
*** Low-level Font
* elispinfo  叶文彬
** 基础知识
+ setq 可以直接给变量赋值
+ defvar 如果变量在声明之前有值的话，不会改变已有值
+ let 和 let* 可以进行局部变量的绑定，区别是 let* 声明中就能使用前面声明的变量
+ lambda 表达式
+ 控制结构
  - 顺序执行
    * progn
  - 条件判断
    * if
    * cond
  - 循环
    * while
  - 逻辑运算
    * and 常用于参数检查
    * or 常用于设置参数缺省值
    * not
+ 函数列表

#+BEGIN_SRC elisp
(deffun NAME ARGLIST [DOCSTRING] BODY ...)
(defvar SYMBOL &optional INITVALUE DOCSTRING)
(setq SYM VAL SYM VAL ...)
(let VARLIST BODY...)
(let* VARLIST BODY...)
(lambda ARGS [DOCSTRING] [INTERACTIVE] BODY)
(progn BODY...)
(if COND THEN ELSE ...)
(cond CLAUSES...)
(when COND BODY...)
(unless COND BODY...)
(or CONDITIONS ...)
(and CONDITIONS ...)
(not OBJECT)
#+END_SRC
** 基本数据类型之一-- 数字
*** 函数列表
#+BEGIN_SRC elisp
(log ARG &optional BASE)
(log10 ARG)
(random &optional N)
#+END_SRC

*** 变量列表 
most-positive-fixnum
most-negative-fixnum
*** 测试函数
  - integerp
  - floatp
  - numberp 
*** 数的比较
  - >, <, =, <=, >=, /=
  - eql 不仅测试数值是否相等，还测试类型是否一致
*** 数的转换
  + truncate 转换成靠近0的整数
  + floor
  + ceiling 
  + round
*** 数的运算
  + 四则运算 +, -, *, /, mod, %(要求第一个参数为整数),  1+, 1-
  + 宏 incf, decf (cl.el)
  + abs, sin, cos, tan, asin, atan, sqrt, exp, log, random
** 基本数据类型之二-- 字符和字符串
*** 函数列表
#+BEGIN_SRC elisp
(format STRING &rest OBJECT)
(string-match REGEXP STRING &optional START)
(replace-match NEWTEXT &optional FIXEDCASE LITERAL STRING SUBEXP)
(replace-regexp-in-string REGEXP REP STRING &optional FIXEDCASE LITERAL SUBEXP START)
(subst-char-in-string FROMCHAR TOCHAR STRING &optional INPLACE)
#+END_SRC

*** 字符表示法
  - ?A 表示 字符 A
  - 标点同样加问题，但最好加上 转义字符\, 如?+ 和 ?\+ 表示都是加号
  - ?\^I, ?\^i, ?\C-I, ?\C-i 都表示数字 9，是控制字符<tab> ?\t
*** 测试函数
  + stringp 
  + string-or-null-p
  + char-or-string-p
  + 无charp
*** 构造函数
  + (make-string 5 ?x) => "xxxxx"
  + (string ?a ?b ?c)  => "abc"
  + (substring "01234567890" 3)
  + (substring "01234567890" 3 5)
  + (substring "01234567890" -3 -1)
  + concat 

*** 字符串比较
  + char-equal 区分大小写的字符比较，受变量case-fold-search影响
  + string=, string-equal

*** 字符串转换
  + (string-to-number "256") ;=> 256
  + (number-to-string 256") ;=> "256"
  + (format "%#o" 256) ;=> "0400"
  + (format "%#x" 256) ;=> "0x100"
  + (vconcat "abc") ;=> [a b c]
  + (append "abc" nil) ;=>(97 98 99)
  + (downcase "HELLO WORLD")
  + (upcase "hello world")
  + (capitalize "tHE cAT in hHE hAT")
  + (upcase-initials "The CAT in the hAt")

*** 格式化字符串
  + format

*** 查找和替换
  + (string-match "34" "01234567890") ;=> 3
  + (string-match "34" "0123456789012345" 10) ;=> 13
  + (string-match "2*" "232*3=696") ;=> 0
  + (string-match (regexp-quote "2*") "232*3=696") ;=> 2
  + (match-data)
  + match-beginning, match-end
  + replace-match

** 基本数据类型之三-- cons cell 和 列表
*** 函数列表
#+BEGIN_SRC emacs-lisp
;;列表测试
(consp OBJECT)
(listp OBJECT)
(null OBJECT)
;;列表构造
(cons CAR CDR)
(list &rest SEQUENCES)
(append &rest SEQUENCES)
;;访问列表
(car LIST)
(cdr LIST)
(cadr X)
(caar X)
(cddr X)
(cdar X)
(nth N LIST)
(nthcdr N LIST)
(last LIST &optional N)
(butlast LIST &optional N)
;;修改cons cell
(setcar CELL NEWCAR)
(setcdr CELL NEWCDR)
;;列表操作
(push NEWELT LIST)
(pop LIST)
(reverse LIST)
(nreverse LIST) ;;破坏性
(sort LIST PREDICATE) ;;破坏性，要保持原来列表又要排序，可借助 copy-sequence
(copy-sequence ARG)
(nconc &rest LISTS)
(nbutlast LIST &optional N)
;;集合函数
(delete-dups LIST)
(memq ELT LIST)  ;;memq 与 member 的区别如同 eq 与 equal 的区别
(member ELT LIST)
(delq ELT LIST)
(delete ELT SEQ)
(remq ELT LIST)
(remove ELT SEQ)
;;关联表
(assoc KEY LIST)
(assq KEY LIST)
(assoc-default KEY ALIST &optional TEST DEFAULT)
(rassoc KEY LIST) ;;根据值返回关联表
(rassq KEY LIST)
;;遍历函数
(mapc FUNCTIOIN SEQUENCE) ;;返回输入的参数列表
(mapcar FUNCTION SEQUENCE) ;;返回函数返回值构成的列表
(dolist (var LIST [RESULT] BODY...)
;;其他 
(number-sequence FROM &optional TO INC)
(split-string STRING &optional SEPARATORS OMIT-NULLS)
(mapconcat FUNCTION SEQUENCE SEPARATOR)
(identity ARG)
#+END_SRC

** 基本数据类型之四-- 序列和数组
*** 函数列表
#+BEGIN_SRC elisp
(sequencep OBJECT)
(arrayp OBJECT)
(vectorp OBJECT)
(char-table-p OBJECT)
(bool-vector-p OBJECT)
;;序列函数
(length SEQUENCE)
(safe-length LIST)
(elt SEQUENCE)
(copy-sequence ARG)
(copy-tree TREE &optional VECP)
;;数组函数
(vector &rest OBJECT)
(make-vector LENGTH INIT)
(aref ARRAY IDX)
(aset ARRAY IDX NEWELT)
(vconcat &rest SEQUENCE)
(append &rest SEQUENCE)
#+END_SRC
** 基本数据类型之五--符号
*** 创建符号
    + intern 在obarray里插入符号
    + intern-soft 若 obarray 里不存在，则返回 nil
    + unintern
    + mapatoms 提供了遍历 obarray 的方法
*** 符号的组成
    + symbol-name 符号名
    + symbol-value 符号值 (setq 来设置，但setq 只应用于 obarray,set可用于任意场合)
    + symbol-function : fset 来设置，fboundp来测试
    + symbol-plist : put, get, plist-put, plist-get 



*** 函数列表
#+BEGIN_SRC elisp
(symbolp OBJECT)
(intern-soft NAME &optional OBARRAY)
(intern STRING &optional OBARRAY)
(unintern NAME &optional OBARRAY)
(mapatoms FUNCTIO &optional OBARRAY)
(symbol-name SYMBOL)
(symbol-value SYMBOL)
(boundp SYMBOL)
(set SYMBOL NEWVAL)
(setq SYM VAL SYM VAl ...)
(symbol-function SYMBOL)
(fset SYMBOL DEFINITION)
(fboundp SYMBOL)
(symbol-plist SYMBOL)
(get SYMBOL PROPNAME)
(put SYMBOL PROPNAME VALUE)
#+END_SRC   

* cl.el
** MACROs  
  + (incf place &optional x)
  + (decf place &optional x)
  + (pop place)
  + (push x place)
  + (pushnew x place &rest keys)
** FUNCTIONs
  + (cl-set-elt seq n val)
  + (cl-set-nthcdr n list x)
  + (cl-set-buffer-substring start end val)
  + (cl-set-substring str start end val)
** Control Structures.
  + (cl-map-extents &rest cl-args)
** Multiple values
  + (values &rest values)
  + (values-list list)
  + (multiple-value-list expression)
  + (multiple-value-apply function expression)
** Declarations.
  + (cl-compiling-file)
** Symbols.
  + (cl-random-time)
  + *gensym-counter*
** Numbers.
   + (floatp-safe object)
   + (plusp number)
   + (minusp number)
   + (oddp integer)
   + (evenp integer)
** Sequence function
   + (copy-sequence)
   + (mapcar* cl-func cl-x &rest cl-rest)
   + (third x)
   + (fifth x)
   + (caddr x)
   + (list* arg &rest rest)
   + (copy-list list)
   + (adjoin cl-item cl-list &rest cl-keys)
   + (subst cl-new cl-old cl-tree &rest cl-keys)
* Lisp Data Types
** Programming Types
*** Integer Type
*** Floating Point Type
*** Character Type
*** Symbol Type
*** Sequence type
*** Cons Cell Type
* elispintro
** 数据类型之 - 数字
*** 语法
+ #b101100 => 44 :: 二进制
+ #o54 => 44  :: 八进制
+ #x2c => 44  :: 16进制
+ #24r1k => 44 :: 24进制
*** 测试函数
integerp
floatp
numberp
*** 比较
    >, <, >=, <=, /=(不等于), eql（同时比较数值和数字类型是否一致)
    eg: (= 1.0 1) => t
        (eql 1.0 1) => nil
*** 其他
    most-positive-fixnum
    most-negative-fixnum
** 数据类型之 - 字符和字符串
普通字符以 ? 开始
标点符号最好以 ?\  开始
控制字符以 ?\C- or ?\^ 开始, eg: ?\^i, ?\^I, ?\C-i, ?\C-I
Meta 字符 ?\M- 开始, eg: ?\M-A
*** 测试函数
    + stringp
    + string-or-null-p
    + char-or-string-p
*** 生成函数
    + (make-string 5 ?x) => "xxxxx"
    + (string ?a ?b ?c) => "abc"
    + (substring  "abc" 1 3) => "bc"
    + (concat "hello" "world") => "hello world"
  
*** 比较
    + (char-equal ?a ?a) => t :: 当 case-fold-search 为 t 时比较忽略大小写
    + (string= "a" "a")

*** 字符（串）转换
    + (string-to-number "256") => 256
    + (string-to-number "256" 10) => 256
    + (number-to-string 256) => "256
    + (format "%#o" 256) => "0400"
    + (format "%#x" 256) => "0x100"
    + concat 可将字符 列表 or 向量 转化成字符串
    + vconcat 可将字符串转化成 字符 向量
    + (append "abcde" nil) => (a b c d e) :: append 可将字符串转化成列表
    + (downcase "ABC") => "abc"
    + (upcase "abc") => "ABC"
    + (capitalize "aBc") => "Abc"
    + (upcase-initials "hEllo wOrld") => "HEllo WOrld"

*** 字符串查找替换
    + (string-match REGEXP STRING &optional START) :: 在 string 中 start 处开始查找正则表达式
    + (regexp-quote "he*'") :: 返回可严格表示字符串的正则表达式
    + (match-data) :: 返回正则组的捕获位置组
    + (match-beginning idx) & (match-end idx) ::返回正则组的序号
    + replace-regexp-in-string
    + subst-char-in-string

** 数据类型之 - cons cell 和 列表
*** 语法
    (read "(1 2)") => (1 2)
    (car '(1 2))
    (cdr '(1 2))
*** 测试函数
    + consp
    + listp
*** 构造函数
    + (cons 'a 'b) => (a . b)
    + (list 'a 'b 'c) => (a b c)
    + (cons 'x '(a b)) => (x a b) ::若 (setq foo '(a b)) (push 'x foo)会改变foo值 foo => (x a b)
    + (append '(a b) 'x) => (a b . x) :: append 可用于列表、向量、字符串数组
*** 列表操作
    + car
    + cdr
    + cadr ::  访问第二个列表的第二个元素 
    + nthcdr ::返回第n个后的元素
    + last ::返回倒换n个元素
    + butlast ::返回除了倒数n个的其他元素
    + setcar
    + setcdr
    + push
    + pop
    + reverse
    + nreverse :: 具破坏性
    + sort :: 具破坏性 
    + copy-sequence
    + nconc :: 在列表后添加元素，与append不同的是会改变原列表. 注意:nconc或append的第二个参数不是列表，则返回的列表就不再是真列表了
    + delete-dups :: 删除列表中equal的元素 
    + memq :: 判断是否是列表中元素，用eq 测试
    + member :: 用equal测试
    + remq 
    + remove
    + delq
    + delete :: 上述四个都是从列表中删除元素 del*会更改原列表
*** 关联表*
    + assq ::用KEY查关联表，用eq, 返回cons cell，进而用cdr可得值
    + assoc ::同上，用equal
    + assoc-default :: 用KEY找出关联表中对应值 
    + rassq ::用值查关联表，返回cons cell,进而car可得KEY
*** 遍历列表
    + mapc
    + mapcar
    + dolist
*** 其他
    + remove-if
    + number-sequence :: 产生数列 
    + split-string
    + mapconcat :: 用分隔符连接字符串
    + identity
** 数据类型之 - 符号 
*** 创建 symbol
    + intern ::用符号或符号名查找或添加符号到obarray,当存在时返回符号，不存在时添加
    + intern-soft ::查找符号，存在时返回符号，不存在时返回nil
    + #: :: 若不想将符号intern到obarray中，可在符号前加`#:'
    + unintern :: 从obarray中去除符号
    + mapatoms :: 遍历obarray
*** 操作  symbol 
    * symbol name
      + symbol-name ::查看symbol的名字
    * 值
      + symbol-value ::返回symbol值 
      + set ::设置symbol的value
      + setq ::设置symbol的value，只能设置obarray中符号的值 
      + boundp ::判断symbol值是否设置
    * function
      + symbol-functoin ::返回符号的function
      + fset ::设置符号的function
      + fboundp ::判断符号function是否设置
      + funcall 
    * 属性列表
      + put
      + get
      + symbol-plist
      + plist-get
      + plist-put
** 变量
   + make-local-variable ::在当前buffer中设置buffer-local变量
   + make-variable-buffer-local ::在所有buffer中声明buffer-local变量
   + default-value ::访问buffer-local变量的全局值缺省值 
   + local-variable-p ::测试是否是buffer-local变量
   + buffer-local-value ::返回某buffer中的buffer-local变量
   + kill-local-variable(s) ::(s)消除所有没有permanet-local属性的变量
   + boundp :: 检测变量值是否设置
   + default-boundp :: 检测全局缺省值是否是为空 
   + makeunbound :: 使变量值为空
** 函数和命令
*** 测试命令 functionp
*** 函数调用
   + eval
   + funcall :: 将参数按原始形式传给函数
   + apply :: 将参数平铺后传给函数，两者都会返参数列表 
***　宏
　　+ macroexpand		
** 正则表达式
* Emacs Lisp ::`(elisp) Top'
** Files
*** Visiting Files
*** Saving Buffers
*** Reading from Files
*** Writing to Files
*** File Locks
*** Information about Files
*** Changing Files
*** File Names
*** Contents of Directories
*** Create/Delete Dirs
*** Magic File Names
*** Format Conversion
    
** Buffers
*** Buffer Basics
 -- Function: bufferp object
*** Current Buffer
 -- Function: current-buffer
 -- Function: set-buffer buffer-or-name
 -- Special Form: save-current-buffer body
 -- Macro: with-temp-buffer body
`save-current-buffer'
`with-current-buffer'
*** Buffer Names
 -- Function: buffer-name &optional buffer
 -- Command: rename-buffer newname &optional unique
 -- Function: get-buffer buffer-or-name
 -- Function: generate-new-buffer-name starting-name &optional ignore
*** Buffer File Names
 -- Function: buffer-file-name &optional buffer
 -- Variable: buffer-file-name
 -- Variable: buffer-file-truename
 -- Function: get-file-buffer filename
 -- Function: find-buffer-visiting filename &optional predicate
 -- Variable: list-buffers-directory
*** Buffer Modification
 -- Function: buffer-modified-p &optional buffer
 -- Function: set-buffer-modified-p flag
 -- Function: restore-buffer-modified-p flag
 -- Command: not-modified &optional arg
 -- Function: buffer-modified-tick &optional buffer
 -- Function: buffer-chars-modified-tick &optional buffer
*** Modification Time
 -- Function: verify-visited-file-modtime &optional buffer
 -- Function: clear-visited-file-modtime
 -- Function: visited-file-modtime
 -- Function: set-visited-file-modtime &optional time
 -- Function: ask-user-about-supersession-threat filename
*** Read Only Buffers
 -- Variable: buffer-read-only
 -- Variable: inhibit-read-only
 -- Command: toggle-read-only &optional arg
 -- Function: barf-if-buffer-read-only
*** The Buffer List
 -- Function: buffer-list &optional frame
 -- Function: other-buffer &optional buffer visible-ok frame
 -- Function: last-buffer &optional buffer visible-ok frame
 -- Command: bury-buffer &optional buffer-or-name
*** Creating Buffers
 -- Function: get-buffer-create buffer-or-name
 -- Function: generate-new-buffer name
*** Killing Buffers
 -- Command: kill-buffer &optional buffer-or-name
 -- Variable: kill-buffer-query-functions
 -- Variable: kill-buffer-hook
 -- User Option: buffer-offer-save
 -- Variable: buffer-save-without-query
 -- Function: buffer-live-p object
*** Indirect Buffers
 -- Command: make-indirect-buffer base-buffer name &optional clone
 -- Command: clone-indirect-buffer newname display-flag &optional norecord
 -- Function: buffer-base-buffer &optional buffer
*** Swapping Text
 -- Function: buffer-swap-text buffer
*** Buffer Gap
 -- Function: gap-position
 -- Function: gap-size
** Completion
   - Function: try-completion string collection &optional predicate :: 返回匹配的common部分
   - Function: all-completions string collection &optional predicate :: 返回所有的匹配
   - Function: test-completion string collection &optional predicate 
   - Function: completion-boundaries string collection predicate suffix
   - Variable: completion-ignore-case
   - Variable: completion-regexp-list
   - Macro: lazy-completion-table var fun

* Usual Functions
** Visiting Files
   + -- Command: find-file filename &optional wildcards等同于
(switch-to-buffer (find-file-noselect filename nil nil wildcards))如果
有对应的 buffer 则切过去，否则读文件到 buffer 中
   + -- Command: find-file-literally filename按文件的字节序读，不转码，不
处理行尾，不处理文件 local variables若文件对应的 buffer 已经存在，则直
接转到 buffer ， 不重新读文件。若一定要按字节序读，可使用
insert-file-contents-literally 到临时buffer中
   + -- Function: find-file-noselect filename &optional nowarn rawfile核心
函数，参考 manual 该函数执行完成后会调用 `after-find-file', 最后
`find-file-hook' find-file-noselect 会调 create-file-buffer,
create-file-buffer 会调 generate-new-buffer
  + -- Function: create-file-buffer filename
  + -- Function: after-find-file &optional error warn noauto
  + -- Command: find-file-other-window filename &optional wildcards
  + -- Command: find-file-read-only filename &optional wildcards
** Saving Buffers
** File
   + expand-file-name
   + abbreviate-file-name
* Debug
** 
* emergency elisp
http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html
  
;; 建议查看原文网页版 [fn:1]
  
;; 转载过来就乱了排版
  
Thursday, January 24, 2008
  
Emergency Elisp
  
Are you an Emacs user but don't know Lisp? Welcome to my first Emacs Lisp primer! This should hopefully help
get you over the hurdle so you can have more control over your Emacs sessions.
  
There are lots of ways to do things in Lisp, and some are "Lispier" than others. I'm going to focus on how
to do things you probably already know how to do from C++ or Java.
  
I'm mostly focusing on the language itself, since that's arguably the hardest part. There are tons of
Emacs-specific APIs that you can learn how to use from the documentation.
  
Lisp is good at some things (like code that generates code) and not so good at others (like arithmetic
expressions). I will generally avoid talking about good vs. bad, and just talk about how to do things. Emacs
Lisp is like any other language – you get used to it eventually.
  
Most Lisp introductions try to give you the "Tao of Lisp", complete with incense-burning, chanting, yoga and
all that stuff. What I really wanted in the beginning was a simple cookbook for doing my "normal" stuff in
Lisp. So that's what this is. It's an introduction to how to write C, Java or JavaScript code in Emacs Lisp,
more or less.
  
Here goes. Let's see how short I can make it. I'll start with the boring (but hopefully familiar) lexical
tokens and operators, then move on to how to implement various favorite statements, declarations and other
programming constructs.
  
Quick Start
  
Lisp is written as nested parenthesized expressions like (+ 2 3). These expressions are sometimes called  
forms (in the sense of "shapes".)
  
There are also "atoms" (leaf nodes, basically) that are not parenthesized: strings, numbers, symbols (which
must be quoted with apostrophe for use as symbols, like 'foo), vectors, and other miscellany.
  
There are only single-line comments: semicolon to end of line.
  
To set a variable named foo to the value "bar":
  
(setq foo "bar")  ; setq means "set quoted"
  
To call a function named foo-bar with arguments "flim" and "flam":
  
(foo-bar "flim" "flam")
  
To compute the arithmetic expression (0x15 * (8.2 + (7 << 3))) % 2:
  
(% (* #x15 (+ 8.2 (lsh 7 3))) 2)
  
In other words, arithmetic uses prefix notation, just like lisp function calls.
  
There's no static type system; you use runtime predicates to figure out the type of a data item. In elisp,
predicate functions often end with "p". I'll let you figure out what it stands for.
  
Important: You can (and should) experiment with Lisp in the *scratch* buffer. You can evaluate an expression
and see its result in any of several ways, including:
  
  1. Put your cursor after the last close-paren and type C-j (control + j)
  2. Put your cursor inside the expression and type M-C-x (alt + control + x)
  3. Put your cursor after the last close-paren and type C-x C-e
  
The first approach spits the result into the *scratch* buffer, and the next two echo it into the minibuffer.
They all also work for atoms – expressions not in parens such as numbers, strings, characters and symbols.
  
Lexical Stuff
  
Lisp has only a handful of lexical tokens (i.e. atomic program elements).
  
Comments:
  
Single-line only. They start with a semicolon:
  
(blah blah blah)   ;  I am a comment
  
Strings:
  
Double-quoted only.
  
"He's said: \"Emacs Rules\" one time too many."
  
You can embed newlines in strings, like so:
  
"Oh Argentina!
Your little tin of pink meat
Soars o'er the Pampas"
  
Characters:
  
      ?x is the syntax for an ASCII character: ? followed by the character.
      e.g.: ?a is ascii 97 ('a'), ? (that is, question-mark space) is ascii 32 (' ').
      Some need to be escaped, such as ?\(, ?\) and ?\\
      Emacs 22+ has unicode support. Out of scope for this primer.
  
Characters are just int values internally, so you can use arithmetic operations on them (for instance, to
iterate through ?a to ?z).
  
Numbers:
  
      Integers are 29 bits of precision (not the usual 32). -32, 0, 157, etc.
      Binary: start with #b, e.g. #b10010110
      Octal: #o[0-7]+, e.g. #o377
      Hexadecimal: start with #x, e.g. #xabcd, #xDEADBEE
      Floating-point: the usual. -10.005, 0.0, 3.14159265 (64 bits of precision.)
      Scientific: the usual. 6.02e23, 5e-10
  
The variables most-positive-fixnum and most-negative-fixnum are the largest and smallest integers
representable in Emacs Lisp without bignum support. Emacs 22+ comes with a fancy bignum/math library called
calc, if you need it. Arithmetic operations overflow and underflow the way you'd expect (in, say, C or
Java.)
  
Booleans
  
The symbol t (just a letter 't' by itself) is true.
  
The symbol nil is false (and also means null).
  
In Emacs Lisp, nil is the only false value; everything else evalutes to true in a boolean context, including
empty strings, zero, the symbol 'false, and empty vectors. An empty list, '(), is the same thing as nil.
  
Arrays
  
Elisp has fixed-sized arrays called "vectors". You can use square-brackets to create a pre-initialized
literal vector, for instance:
  
[-2 0 2 4 6 8 10]
["No" "Sir" "I" "am" "a" "real" "horse"]
["hi" 22 120 89.6 2748 [3 "a"]]
  
Note that you do not (and cannot) use commas to separate the elements; use whitespace.
  
Vectors can have mixed-type elements, and can be nested. You usually use the function make-vector to create
them, since literal vectors are singletons, which can be surprising.
  
Lists
  
Lisp makes heavy use of linked lists, so there's lexical syntax for them. Anything in parentheses is a list,
but unless you quote it, it will be evaluated as a function call. There are various ways to quote things in
Lisp:
  
(quote (1 2 3)) ; produces the list (1 2 3) with no list-element evaluation
  
'(1 2 3)  ; apostrophe is shorthand for (quote (...))
           ; note that it goes _outside_ the left-paren
  
(list 1 (+ 1 1) 3) ; also produces (1 2 3), since it evaluates the elements first
  
`(1 ,(+ 1 1) 3)  ; another (1 2 3) via a template system called "backquote"
  
There's a lot more that could be said about lists, but other people have already said it.
  
Pairs
  
You can set the head and tail (also known as car and cdr) fields of a lisp link-list node struct (also known
as a cons cell) directly, using it as a 2-element untyped struct. The syntax is (head-value . tail-value),
and you have to quote it (see above).
  
A common lookup-table data-structure for very small data sets is an associative list (known as an alist).
It's just a list of dotted pairs, like so:
  
'( (apple . "red")
    (banana . "yellow")
    (orange . "orange") )
  
Emacs Lisp has built-in hashtables, bit-vectors, and miscellaneous other data structures, but there's no
syntax for them; you create them with function calls.
  
Operators
  
Some operations that are typically operators in other languages are function calls in elisp.
  
Equality
  
Numeric equality: (= 2 (+ 1 1)) Single-equal. Yields t or nil. Works for floats too.
  
Not-numerically-equal: (/= 2 3) I know, it looks like assign-divide-equal. But it's not.
  
Value equality: (eq 'foo 2) Like Java ==. Works for ints, symbols, interned strings, and object references.
Use eql for floating-point numbers (or just =).
  
Deep (structural) equality: use equal, as in:
  
(equal '(1 2 (3 4)) (list 1 2 (list 3 (* 2 2))))  ; true
  
The equal function is like Java's Object.equals(). Works for lists, vectors, strings, and just about
anything else.
  
String
  
Strings don't have any operators, but there are lots of string functions. Some common ones:
  
(concat "foo" "bar" "baz")  ; yields "foobarbaz"
  
(string= "foo" "baz")  ; yields nil (false).  Can also use equal.
  
(substring "foobar" 0 3) ; yields "foo"
  
(upcase "foobar")  ; yields "FOOBAR"
  
Do M-x apropos RET \bstring\b RET to see a list of functions related to strings.
  
Arithmetic
  
Easiest to show as a table...
┌──────────────────┬──────────────────────────────────┬──────────────────┬────────────────────────────┐
│C/Java/JS Operator│            Emacs Lisp            │     Example      │           Result           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│+                 │+                                 │(+ 1 2 3 4 5)     │15                          │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│-                 │-                                 │(- 6 2 3)         │1                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│*                 │*                                 │(* 2 -1 4.2)      │-8.4                        │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│/                 │/                                 │(/ 10 3)          │3 (use floats for float div)│
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│%                 │%                                 │(% 10 2)          │0                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│<<                │lsh                               │(lsh 1 5)         │32                          │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│>>                │ash (negative amount)             │(ash -32 -4)      │-2                          │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│>>>               │lsh (negative amount)             │(lsh 32 -4)       │2                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│++                │incf (requires 'cl library)       │(incf x 6)        │x+6                         │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│--                │decf (ditto)                      │(decf x 5)        │x-5                         │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│? : (ternary)     │(if test-expr then-expr else-expr)│(if t 3 4)        │3                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│&&                │and                               │(and t t t nil)   │nil                         │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│||                │or                                │(or nil nil nil t)│t                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│! (logical-not)   │not                               │(not 3)           │nil                         │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│~ (bit-not)       │lognot                            │(lognot #b1001)   │-10                         │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│^ (bit-xor)       │logxor                            │(logxor 5 3)      │6                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│& (bit-and)       │logand                            │(logand 1 3)      │1                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│| (bit-or)        │logior                            │(logior 1 3)      │3                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│<                 │<                                 │(< 5 3)           │nil                         │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│>                 │>                                 │(> 5 3)           │t                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│<=                │<=                                │(<= 3 3)          │t                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│>=                │>=                                │(>= 5 3)          │t                           │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│. (field access)  │see setf below                    │n/a               │n/a                         │
├──────────────────┼──────────────────────────────────┼──────────────────┼────────────────────────────┤
│[] (array access) │aref/aset                         │(aref [2 4 6] 1)  │4                           │
└──────────────────┴──────────────────────────────────┴──────────────────┴────────────────────────────┘
  
Statements
  
This section has some recipes for simple Java-like statements. It's not comprehensive – just some recipes to
get you going.
  
if/else
  
Case 1: no else clause: (if test-expr expr)
  
Example:
  
(if (>= 3 2)
   (message "hello there"))
  
Case 2: else clause: (if test-expr then-expr else-expr)
  
(if (today-is-friday)         ; test-expr
     (message "yay, friday")   ; then-expr
   (message "boo, other day")) ; else-expr
  
If you need multiple expressions (statements) in the then-expr, you wrap them with a call to progn, which is
like curly-braces in C or Java:
  
(if (zerop 0)
     (progn
       (do-something)
       (do-something-else)
       (etc-etc-etc)))
  
You don't need the progn around the else-expr – everything after the then-expr is considered to be part of
the else-expr. Hence:
  
(if (today-is-friday)
     (message "yay, friday")
   (message "not friday!")
   (non-friday-stuff)
   (more-non-friday-stuff))
  
Case 3: else-if clause: Just nest 'em. Or use cond (see below).
  
(if 'sunday
     (message "sunday!")      ; then-expr
   (if 'saturday              ; else-if
       (message "saturday!")  ; next then-expr
     (message ("weekday!")))) ; final else
  
Case 4: no else-if, multiple body expressions – use when:
  
If you don't have an else-clause, then you can use the when macro, which provides an implicit progn:
  
(when (> 5 1)
   (blah)
   (blah-blah)
   (blah blah blah))
  
You can also use unless, which is like when but inverts the sense of the test:
  
(unless (weekend-p)
   (message "another day at work")
   (get-back-to-work))
  
switch
  
Elisp has two versions of the classic switch statement: cond and case.
  
Elisp does not have a table-lookup optimization for switch, so cond and case are just syntax for nested
if-then-else clauses. However, if you have more than one level of nesting, it looks a lot nicer than if
expressions. The syntax is:
  
(cond
   (test-1
     do-stuff-1)
   (test-2
     do-stuff-2)
   ...
   (t
     do-default-stuff))
  
The do-stuff parts can be any number of statements, and don't need to be wrapped with a progn block.
  
Unlike classic switch, cond can handle any test expression (it just checks them in order), not just numbers.
The downside is that it doesn't have any special-casing for numbers, so you have to compare them to
something. Here's one that does string compares:
  
(cond
  ((equal value "foo")  ; case #1 – notice it's a function call to `equal' so it's in parens
   (message "got foo")  ; action 1
   (+ 2 2))             ; return value for case 1
  ((equal value "bar")  ; case #2 – also a function call (to `+')
   nil)                 ; return value for case 2
  (t                    ; default case – not a function call, just literal true
   'hello))             ; return symbol 'hello
  
The final t default clause is optional. The first matching clause is executed, and the result of the entire
cond expression is the result of the last expression in the matching clause.
  
The 'cl (Common Lisp) package bundled with Emacs provides case, which works if you're comparing numbers or
symbols, so in a sense it works more like standard switch. Example:
  
(case 12
   (5 "five")
   (1 "one")
   (12 "twelve")
   (otherwise
    "I only know five, one and twelve."))  ; result:  "twelve"
  
With case you can use either t or otherwise for the default case, but it must come last.
  
It's cleaner to use case when you can get away with it, but cond is more general.
  
while
  
Elisp has a relatively normal while function: (while test body-forms)
  
Example, which you can evaluate in your *scratch* buffer:
  
(setq x 10
       total 0)
(while (plusp x)  ; while x is positive
   (incf total x)  ; add x to total
   (decf x))       ; subtract 1 from x
  
First we set two global variables, x=10 and total=0, then run the loop. Then we can evaluate the expression
total to see that its value is 55 (the sum of the numbers 1 to 10).
  
break/continue
  
Lisp has a facility for upward control-flow transfers called catch/throw. It's very similar to Java or C++
exception handling, albeit possibly somewhat lighter-weight.
  
To do a break from inside a loop in elisp, you put a (catch 'break ...) outside the loop, and a (throw
'break value) wherever you want to break inside the loop, like so:
┌──────────────────────────────────┬────────────────────┐
│            Emacs Lisp            │        Java        │
├──────────────────────────────────┼────────────────────┤
│                                  │ var x = total = 0; │
│ (setq x 0 total 0)               │ while (true) {     │
│ (catch 'break                    │   total += x;      │
│   (while t                       │   if (x++ > 10) {  │
│     (incf total x)               │     break;         │
│     (if (> (incf x) 10)          │   }                │
│         (throw 'break total))))  │ }                  │
└──────────────────────────────────┴────────────────────┘
  
The symbol 'break is arbitrary, but is probably a nice choice for your readers. If you have nested loops,
you might consider 'break-outer and 'break-inner in your catch expressions.
  
You can (throw 'break nil) if you don't care about the "return value" for the while-loop.
  
To continue a loop, put a catch expression just inside the loop, at the top. For instance, to sum the
numbers from 1 to 99 that are not evenly divisible by 5 (artificially lame example demonstrating use of
continue):
┌─────────────────────────────────┬─────────────────────┐
│           Emacs Lisp            │        Java         │
├─────────────────────────────────┼─────────────────────┤
│ (setq x 0 total 0)              │ var x = total = 0;  │
│ (while (< x 100)                │ while (x < 100) {   │
│   (catch 'continue              │   x++;              │
│     (incf x)                    │   if (x % 5 == 0) { │
│     (if (zerop (% x 5))         │     continue;       │
│         (throw 'continue nil))  │   }                 │
│     (incf total x)))            │   total += x;       │
│                                 │ }                   │
└─────────────────────────────────┴─────────────────────┘
  
We can combine these examples to show using a break and continue in the same loop:
┌───────────────────────────────────┬─────────────────────┐
│            Emacs Lisp             │     JavaScript      │
├───────────────────────────────────┼─────────────────────┤
│ (setq x 0 total 0)                │ var x = total = 0;  │
│ (catch 'break                     │ while (true) {      │
│   (while t                        │   x++;              │
│     (catch 'continue              │   if (x >= 100) {   │
│       (incf x)                    │     break;          │
│       (if (>= x 100)              │   }                 │
│           (throw 'break nil))     │   if (x % 5 == 0) { │
│       (if (zerop (% x 5))         │     continue;       │
│           (throw 'continue nil))  │   }                 │
│       (incf total x))))           │   total += x;       │
│                                   │ }                   │
└───────────────────────────────────┴─────────────────────┘
  
All the loops above compute the value 4000 in the variable total. There are better ways to compute this
result, but I needed something simple to illustrate break and continue.
  
The catch/throw mechanism can be used across function boundaries, just like exceptions. It's not intended
for true exceptions or error conditions – Emacs has another mechanism for that, discussed in the try/catch
section below. You should get comfortable using catch/throw for normal jumps and control transfer in your
Elisp code.
  
do/while
  
Pretty much all iteration in Emacs Lisp is easiest using the loop macro from the Common Lisp package. Just
do this to enable loop:
  
(require 'cl)  ; get lots of Common Lisp goodies
  
The loop macro is a powerful minilanguage with lots of features, and it's worth reading up on. I'll use it
in this primer to show you how to do basic looping constructs from other languages.
  
You can do a do/while like so:
  
(loop do
       (setq x (1+ x))
       while
       (< x 10))
  
You can have any number of lisp expressions between the do and while keywords.
  
for
  
The C-style for-loop has four components: variable initialization, the loop body, the test, and the
increment. You can do all that and more with the loop macro. For instance, this arbitrary JavaScript:
  
// JavaScript
var result = [];
for (var i = 10, j = 0; j <= 10; i--, j += 2) {
   result.push(i+j);
}
  
Could be done with loop like so:
  
(loop with result = '()         ; one-time initialization
       for i downfrom 10         ; count i down from 10
       for j from 0 by 2         ; count j up from 0 by 2
       while (< j 10)            ; stop when j >= 10
       do
       (push (+ i j) result)     ; fast-accumulate i+j
       finally
       return (nreverse result)) ; reverse and return result
  
It's a bit more verbose, but loop has a lot of options, so you want it to be reasonably transparent.
  
Notice that this loop declares the result array and then "returns" it. It could also operate on a variable
declared outside the loop, in which case we wouldn't need the finally return clause.
  
The loop macro is astoundingly flexible. Its full specification is way out of scope for this primer, but if
you want to make Emacs Lisp your, uh, friend, then you should spend some time reading up on loop.
  
for..in
  
If you're iterating over a collection, Java provides the "smart" for-loop, and JavaScript has for..in and
for each..in. There are various ways to do it in Lisp, but you really might as well just learn how to do it
with the loop macro. It's a one-stop shop for iteration.
  
The basic approach is to use loop for var in sequence, and then do something with the individual results.
You can, for instance, collect them (or a function on them) into a result list like so:
  
(loop for i in '(1 2 3 4 5 6)
       collect (* i i))           ; yields (1 4 9 16 25 36)
  
The loop macro lets you iterate over list elements, list cells, vectors, hash-keys, hash-values, buffers,
windows, frames, symbols, and just about anything else you could want to traverse. See the Info pages or
your Emacs manual for details.
  
functions
  
You define a function with defun.
  
Syntax: (defun function-name arg-list [optional docstring] body)
  
(defun square (x)
   "Return X squared."
   (* x x))
  
For a no-arg function, you use an empty list:
  
(defun hello ()
   "Print the string `hello' to the minibuffer."
   (message "hello!"))
  
The body can be any number of expressions. The return value of the function is the result of the last
expression executed. You do not declare the return type, so it's useful to mention it in the documentation
string. The doc string is available from M-x describe-function after you evaluate your function.
  
Emacs Lisp does not have function/method overloading, but it supports optional and "rest" parameters similar
to what Python and Ruby offer. You can use the full Common Lisp specification for argument lists, including
support for keyword arguments (see the defstruct section below), if you use the defun* macro instead of
defun. The defun* version also lets you (return "foo") without having to set up your own catch/throw.
  
If you want your function to be available as a M-x command, put (interactive) as the first expression in the
body after the doc string.
  
local variables
  
You declare function local variables with the let form. The basic syntax is (let var-decl var-decl)
  
(let ((name1 value1)
       (name2 value2)
       name3
       name4
       (name5 value5)
       name6
       ...))
  
Each var-decl is either a single name, or (name initial-value). You can mix initialized and uninitialized
values in any order. Uninitialized variables get the initial value nil.
  
You can have multiple let clauses in a function. Code written for performance often collects all
declarations into a single let at the top, since it's a bit faster that way. Typically you should write your
code for clarity first.
  
reference parameters
  
C++ has reference parameters, which allow you to modify variables from the caller's stack. Java does not, so
you have to work around it occasionally by passing in a 1-element array, or using an instance variable, or
whatever.
  
Emacs Lisp does not have true reference parameters, but it has dynamic scope, which means you can modify
values on your caller's stack anyway. Consider the following pair of functions:
  
(defun foo ()
   (let ((x 6))  ; define a local (i.e., stack) variable x initialized to 6
     (bar)       ; call bar
     x))         ; return x
  
(defun bar ()
   (setq x 7))   ; finds and modifies x in the caller's stack frame
  
If you invoke (foo) the return value is 7.
  
Dynamic scoping is generally considered a bad design bordering on evil, but it can occasionally come in
handy. If nothing else, it's good to know it's what Emacs does.
  
return
  
A lisp function by default returns the value of the last expression executed in the function. Sometimes it's
possible to structure your function so that every possible return value is in a "tail position" (meaning the
last expression out before the door closes, so to speak.) For instance:
┌───────────────────────────────────────────┬───────────────────────────────────┐
│                Emacs Lisp                 │            JavaScript             │
├───────────────────────────────────────────┼───────────────────────────────────┤
│ (require 'calendar)                       │ function dayName() {              │
│                                           │   var date = new Date().getDay(); │
│ (defun day-name ()                        │   switch (date) {                 │
│   (let ((date (calendar-day-of-week       │     case 0:                       │
│                (calendar-current-date)))) │       return "Sunday";            │
│     (if (= date 0)                        │     case 6:                       │
│         "Sunday"                          │       return "Saturday";          │
│       (if (= date 6)                      │     default:                      │
│           "Saturday"                      │       return "weekday";           │
│         "weekday"))))                     │   }                               │
│                                           │ }                                 │
└───────────────────────────────────────────┴───────────────────────────────────┘
  
The return value is just the result of the last expression, so whatever our nested if produces is
automatically returned, and there's no need here for an explicit return form.
  
However, sometimes restructuring the function this way is inconvenient, and you'd prefer to do an "early
return".
  
You can do early returns in Emacs Lisp the same way you do break and continue, using the catch/throw
facility. Usually simple functions can be structured so you don't need this – it's most often useful for
larger, deeply-nested functions. So for a contrived example, we'll just rewrite the function above to be
closer to the JavaScript version:
  
(defun day-name ()
   (let ((date (calendar-day-of-week
                (calendar-current-date))))  ; 0-6
     (catch 'return
       (case date
         (0
          (throw 'return "Sunday"))
         (6
          (throw 'return "Saturday"))
         (t
          (throw 'return "weekday"))))))
  
Obviously using catch/throw here is slow and clunky compared to the alternatives, but sometimes it's exactly
what you need to get out of a deeply nested construct.
  
try/catch
  
We've already discussed catch/throw, an exception-like facility for normal control flow transfers.
  
Emacs has a different facility for real error conditions, called the "conditions" system. Going through the
full system is out of scope for our primer, but I'll cover how to catch all exceptions and how to ignore
(squelch) them.
  
Here's an example of a universal try/catch using the condition-case construct, with a Java equivalent:
  
┌─────────────────────────────┬─────────────────────────┐
│         Emacs Lisp          │          Java           │
├─────────────────────────────┼─────────────────────────┤
│ (condition-case nil         │ try {                   │
│     (progn                  │   doSomething();        │
│       (do-something)        │   doSomethingElse();    │
│       (do-something-else))  │ } catch (Throwable t) { │
│   (error                    │   print("uh-oh");       │
│    (message "oh no!")       │   doRecoveryStuff();    │
│    (do-recovery-stuff)))    │ }                       │
└─────────────────────────────┴─────────────────────────┘
  
If you want an empty catch block (just squelch the error), you can use ignore-errors:
  
(ignore-errors
   (do-something)
   (do-something-else))
  
It's sometimes a good idea to slap an ignore-errors around bits of elisp code in your startup file that may
not always work, so you can still at least start your Emacs up if the code is failing.
  
The condition-case nil means "Don't assign the error to a named variable." Elisp lets you catch different
kinds of errors and examine the error data. You can read the Emacs manual or Info pages to learn more about
how to do that.
  
The progn is necessary if you have multiple expressions (in C/Java, statements) to evaluate in the
condition-case body.
  
condition-case will not catch values thrown by throw – the two systems are independent.
  
try/finally
  
Emacs has a "finally"-like facility called unwind-protect.
  
┌─────────────────────────────┬────────────────────────┐
│         Emacs Lisp          │          Java          │
├─────────────────────────────┼────────────────────────┤
│ (unwind-protect             │ try {                  │
│     (progn                  │   doSomething();       │
│       (do-something)        │   doSomethingElse();   │
│       (do-something-else))  │ } finally {            │
│   (first-finally-expr)      │   firstFinallyExpr();  │
│   (second-finally-expr))    │   secondFinallyExpr(); │
│                             │ }                      │
└─────────────────────────────┴────────────────────────┘
  
Like condition-case, unwind-protect takes a single body-form followed by one or more cleanup forms, so you
need to use progn if you have more than one expression in the body.
  
try/catch/finally
  
If you make the condition-case (which is basically try/catch) the body-form of an unwind-protect (which is
basically try/finally), you get the effect of try/catch/finally:
  
(unwind-protect                 ; finally
     (condition-case nil         ; try
         (progn                  ; {
           (do-something)        ;   body-1
           (do-something-else))  ;   body-2 }
       (error                    ; catch
        (message "oh no!")       ; { catch 1
        (poop-pants)))           ;   catch 2 }
   (first-finally-expr)          ; { finally 1
   (second-finally-expr))        ;   finally 2 }
  
Classes
  
Emacs Lisp is not object-oriented in the standard sense: it doesn't have classes, inheritance, polymorphism
and so on. The Common Lisp package includes a useful feature called defstruct that gives you some simple
OOP-like support. I'll walk through a basic example.
  
These two declarations are essentially equivalent:
┌────────────────────────────────┬────────────────────────────────────────────────────────┐
│           Emacs Lisp           │                          Java                          │
├────────────────────────────────┼────────────────────────────────────────────────────────┤
│                                │ /* A Person class */                                   │
│                                │ class Person {                                         │
│                                │   String name;                                         │
│                                │   int age;                                             │
│                                │   double height;                                       │
│                                │   public Person() {}                                   │
│                                │   public Person(String name) {                         │
│                                │     this(name, 0, 0);                                  │
│                                │   }                                                    │
│                                │   public Person(int age) {                             │
│                                │     this(null, age, 0);                                │
│ (require 'cl)  ; top of file   │   }                                                    │
│                                │   public Person(double height) {                       │
│ (defstruct person              │     this(null, 0, height);                             │
│   "A person structure."        │   }                                                    │
│   name                         │   public Person(String name, int age) {                │
│   (age 0)                      │     this(name, age, 0);                                │
│   (height 0.0))                │   }                                                    │
│                                │   public Person(String name, double height) {          │
│                                │     this(name, 0, height);                             │
│                                │   }                                                    │
│                                │   public Person(int age, double height) {              │
│                                │     this(null, age, height);                           │
│                                │   }                                                    │
│                                │   public Person(String name, int age, double height) { │
│                                │     this.name = name;                                  │
│                                │     this.age = age;                                    │
│                                │     this.height = height;                              │
│                                │   }                                                    │
│                                │ }                                                      │
└────────────────────────────────┴────────────────────────────────────────────────────────┘
  
Both create a "class" with three named fields, and constructors for initializing any subset of the fields.
With defstruct you get one constructor with keyword parameters, so these are all valid:
  
(make-person)  ; new Person()
(make-person :age 39)  ; new Person(39)
(make-person :name "Steve" :height 5.83 :age 39)  ; new Person("Steve", 39, 5.83)
  
The defstruct macro supports single-inheritance (to arbitrary depth):
┌────────────────────────────────┬─────────────────────────────────────────────────────────────────┐
│           Emacs Lisp           │                              Java                               │
├────────────────────────────────┼─────────────────────────────────────────────────────────────────┤
│                                │ /* An Employee class */                                         │
│                                │ class Employee extends Person {                                 │
│                                │   String company;                                               │
│                                │   int level = 1;                                                │
│                                │   String title = "n00b";                                        │
│                                │   public Employee() {                                           │
│                                │   }                                                             │
│                                │   public Employee(String name,                                  │
│                                │                   String company) {                             │
│                                │     super(name);                                                │
│                                │     this.company = company;                                     │
│                                │   }                                                             │
│                                │   public Employee(String name,                                  │
│                                │                   int age,                                      │
│                                │                   String company) {                             │
│                                │     super(name, age);                                           │
│                                │     this.company = company;                                     │
│                                │   }                                                             │
│                                │   public Employee(String name,                                  │
│ (defstruct (employee           │                   int age,                                      │
│             (:include person)) │                   double height,                                │
│   "An employee structure."     │                   String company) {                             │
│   company                      │     super(name, age, height);                                   │
│   (level 1)                    │     this.company = company;                                     │
│   (title "n00b"))              │   }                                                             │
│                                │   public Employee(String name,                                  │
│                                │                   int age,                                      │
│                                │                   String company,                               │
│                                │                   int level) {                                  │
│                                │     super(name, age);                                           │
│                                │     this.company = company;                                     │
│                                │     this.level = level;                                         │
│                                │   }                                                             │
│                                │   public Employee(String name,                                  │
│                                │                   int age,                                      │
│                                │                   String co,                                    │
│                                │                   int lvl,                                      │
│                                │                   String title) {                               │
│                                │     super(name, age);                                           │
│                                │     this.company = co;                                          │
│                                │     this.level = lvl;                                           │
│                                │     this.title = title;                                         │
│                                │   }                                                             │
│                                │   // (remaining 150 overloaded constructors elided for brevity) │
│                                │ }                                                               │
└────────────────────────────────┴─────────────────────────────────────────────────────────────────┘
  
The defstruct macro provides a flexible default constructor, but also gives you a fair amount of control
over your constructor(s) if you prefer.
  
The defstruct macro creates an instanceof-like predicate function named after the struct, so you can say:
  
(person-p (make-person))
t
(employee-p (make-person))
nil
(employee-p (make-employee))
t
(person-p (make-employee))  ; yes, it inherits from person
t
  
Java may suck at declaring constructors, but Emacs Lisp makes up for it by sucking at setting fields. To set
a field in a struct, you have to use the setf function, and construct the field name by prepending the
structure name. So:
  
┌─────────────────────────────────────┬──────────────────────────────┐
│             Emacs Lisp              │             Java             │
├─────────────────────────────────────┼──────────────────────────────┤
│ (setq e (make-employee))            │ Employee e = new Employee(); │
│ (setf (employee-name e) "Steve"     │ e.name = "Steve";            │
│       (employee-age e) 39           │ e.age = 39;                  │
│       (employee-company e) "Google" │ e.company = "Google";        │
│       (employee-title e) "Janitor") │ e.title = "Janitor";         │
└─────────────────────────────────────┴──────────────────────────────┘
  
The Lisp one doesn't look too bad here, but in practice (because Elisp has no namespace support and no
with-slots macro), you wind up with long structure and field names. So your defstruct-enabled elisp code
tends to look more like this:
  
(setf (js2-compiler-data-current-script-or-function compiler-data) current-script
       (js2-compiler-data-line-number compiler-data) current-line
       (js2-compiler-data-allow-member-expr-as-function-name compiler-data) allow
       (js2-compiler-data-language-version compiler-data) language-version)
  
So it goes.
  
To fetch the value of a field in a struct variable, you concatenate the struct name with the field name and
use it as a function call:
  
(person-name steve)  ; yields "Steve"
  
There's more that defstruct can do – it's a pretty decent facility, all things considered, though it falls
well short of a full object system.
  
Buffers as classes
  
In Elisp programming it can often be useful to think of buffers as instances of your own classes. This is
because Emacs supports the notion of buffer-local variables: variables that automatically become
buffer-local whenever they are set in any fashion. They become part of the scope chain for any code
executing in the buffer, so they act a lot like encapsulated instance variables.
  
You can use the function make-variable-buffer-local to declare a variable as buffer-local. Usually it comes
right after the defvar or defconst declaration (see below.)
  
Variables
  
You can declare a variable, optionally giving it some runtime documentation, with defvar or defconst:
  
(defconst pi 3.14159 "A gross approximation of pi.")
  
The syntax is (defvar name value [ doc-string ]).
  
Ironically, defconst is variable and defvar is constant, at least if you re-evaluate them. To change the
value of a defvar variable by re-evaluating its declaration you need to use makunbound to unbind it first.
You can always change the value of any defvar or defconst variable using setq. The only difference between
the two is that defconst makes it clearer to the programmer that the value is not intended to change.
  
You can use setq to create brand-new variables, but if you use defvar, the byte-compiler will be able to
catch more typos.
  
Further reading
  
Emacs Lisp is a real programming language. It has a compiler, a debugger, a profiler, pretty-printers,
runtime documentation, libraries, I/O, networking, process control and much more. There's a lot to learn,
but I'm hoping this little primer has got you over the hump, as it were.
  
In spite of its various quirks and annoyances, Elisp is reasonably fun to program in once you get the hang
of it. As a language it's not that great, and everyone wishes it were Common Lisp or Scheme or some other
reasonable Lisp dialect. Some people even wish it weren't Lisp at all, if you can believe that! (hee)
  
But it's really, really useful to be able to customize your editor, and also to be able to fix problems with
elisp code you borrowed or inherited. So a little Elisp goes a long way.
  
For those of you learning Emacs Lisp, please let me know if you found this useful. If you try writing some
Emacs extensions, let me know what you would like to see documented next; I can always do another
installment of the Emergency Elisp series if there's enough interest.
  
Good luck!
Posted by Steve Yegge at 2:47 PM ●
* URI (http://www.gnu.org/software/emacs/manual/html_node/url/index.html#Top)
** URI Parsing(http://www.gnu.org/software/emacs/manual/html_node/url/Parsed-URIs.html#Parsed-URIs)

A URI consists of several components, each having a different meaning. For example, the URI

     http://www.gnu.org/software/emacs/

specifies the scheme component ‘http’, the hostname component ‘www.gnu.org’, and the path component ‘/software/emacs/’.

The format of URIs is specified by RFC 3986. The url library provides the Lisp function url-generic-parse-url, a (mostly) standard-compliant URI parser, as well as function url-recreate-url, which converts a parsed URI back into a URI string.
— Function: url-generic-parse-url uri-string

    This function returns a parsed version of the string uri-string. 

— Function: url-recreate-url uri-obj

    Given a parsed URI, this function returns the corresponding URI string. 

The return value of url-generic-parse-url, and the argument expected by url-recreate-url, is a parsed URI: a CL structure whose slots hold the various components of the URI. See the CL Manual, for details about CL structures. Most of the other functions in the url library act on parsed URIs. 
*** Parsed URI structures
+ type
+ user
+ password
+ host
+ port
+ filename
+ target
+ fullness

The slots can be set using setf. For example:

     (setf (url-port url) 80)

** URI Encoding
— Function: url-encode-url url-string

    This function return a properly URI-encoded version of url-string. It also performs URI normalization, e.g., converting the scheme component to lowercase if it was previously uppercase. 

To convert between a string containing arbitrary characters and a percent-encoded all-ASCII string, use the functions url-hexify-string and url-unhex-string:
— Function: url-hexify-string string &optional allowed-chars

    This function performs percent-encoding on string, and returns the result.

    If string is multibyte, it is first converted to a UTF-8 byte string. Each byte corresponding to an allowed character is left as-is, while all other bytes are converted to a three-character sequence: ‘%’ followed by two upper-case hex digits.

    The allowed characters are specified by allowed-chars. If this argument is nil, the allowed characters are those specified as unreserved characters by RFC 3986 (see the variable url-unreserved-chars). Otherwise, allowed-chars should be a vector whose n-th element is non-nil if character n is allowed. 

— Function: url-unhex-string string &optional allow-newlines

    This function replaces percent-encoding sequences in string with their character equivalents, and returns the resulting string. 
** Retrieving URLs
— Function: url-retrieve-synchronously url
— Function: url-retrieve url callback &optional cbargs silent no-cookies
— Function: url-queue-retrieve url callback &optional cbargs silent no-cookies
    This function acts like url-retrieve, but with limits on the number of concurrently-running network processes. The option url-queue-parallel-processes controls the number of concurrent processes, and the option url-queue-timeout sets a timeout in seconds.

    To use this function, you must (require 'url-queue). 

— User Option: url-queue-parallel-processes

    The value of this option is an integer specifying the maximum number of concurrent url-queue-retrieve network processes. If the number of url-queue-retrieve calls is larger than this number, later ones are queued until ealier ones are finished. 

— User Option: url-queue-timeout

    The value of this option is a number specifying the maximum lifetime of a url-queue-retrieve network process, once it is started. If a process is not finished by then, it is killed and removed from the queue. 
** Command and Function Index

    Info-goto-node: info
    man: man
    terminal-emulator: rlogin/telnet/tn3270
    url-attributes: Parsed URIs
    url-cache-create-filename-human-readable: Disk Caching
    url-cache-create-filename-using-md5: Disk Caching
    url-cache-expired: Disk Caching
    url-completion-function: History
    url-do-setup: History
    url-encode-url: URI Encoding
    url-fetch-from-cache: Disk Caching
    url-filename: Parsed URIs
    url-fullness: Parsed URIs
    url-generic-parse-url: URI Parsing
    url-hexify-string: URI Encoding
    url-history-parse-history: History
    url-history-save-history: History
    url-history-setup-save-timer: History
    url-history-update-url: History
    url-host: Parsed URIs
    url-http-options: HTTP URL Options
    url-open-stream: Gateways in general
    url-password: Parsed URIs
    url-port: Parsed URIs
    url-queue-retrieve: Retrieving URLs
    url-recreate-url: URI Parsing
    url-retrieve: Retrieving URLs
    url-retrieve-synchronously: Retrieving URLs
    url-target: Parsed URIs
    url-type: Parsed URIs
    url-unhex-string: URI Encoding
    url-user: Parsed URIs
** Variable Index

    HTTP_PROXY: Proxies
    mail-user-agent: mailto
    NNTPSERVER: news/nntp/snews
    NO_PROXY: Proxies
    socks-nslookup-program: Gateways in general
    socks-password: Gateways in general
    socks-server: Gateways in general
    socks-timeout: Gateways in general
    socks-username: Gateways in general
    TMPDIR: Customization
    url-automatic-caching: Disk Caching
    url-bad-port-list: Customization
    url-cache-creation-function: Disk Caching
    url-cache-directory: Disk Caching
    url-cache-expire-time: Disk Caching
    url-configuration-directory: Customization
    url-confirmation-func: Customization
    url-cookie-confirmation: Cookies
    url-cookie-file: Cookies
    url-cookie-multiple-line: Cookies
    url-cookie-save-interval: Cookies
    url-cookie-trusted-urls: Cookies
    url-cookie-untrusted-urls: Cookies
    url-debug: Customization
    url-directory-index-file: file/ftp
    url-gateway-local-host-regexp: Gateways in general
    url-gateway-method: Customization
    url-gateway-method: Gateways in general
    url-gateway-prompt-pattern: Gateways in general
    url-gateway-rlogin-host: Gateways in general
    url-gateway-rlogin-parameters: Gateways in general
    url-gateway-rlogin-user-name: Gateways in general
    url-gateway-telnet-host: Gateways in general
    url-gateway-telnet-login-prompt: Gateways in general
    url-gateway-telnet-parameters: Gateways in general
    url-gateway-telnet-password: Gateways in general
    url-gateway-telnet-password-prompt: Gateways in general
    url-gateway-telnet-user-name: Gateways in general
    url-gateway-unplugged: Suppressing network connections
    url-history-file: History
    url-history-hash-table: History
    url-history-save-interval: History
    url-history-track: History
    url-honor-refresh-requests: http/https
    url-irc-function: irc
    url-mail-command: mailto
    url-max-password-attempts: Customization
    url-mime-charset-string: HTTP language/coding
    url-mime-language-string: HTTP language/coding
    url-news-server: news/nntp/snews
    url-nfs-automounter-directory-spec: nfs
    url-passwd-entry-func: Customization
    url-personal-mail-address: Customization
    url-privacy-level: Customization
    url-proxy-services: Proxies
    url-queue-parallel-processes: Retrieving URLs
    url-queue-timeout: Retrieving URLs
    url-show-status: Customization
    url-standalone-mode: Customization
    url-temporary-directory: Customization
    url-uncompressor-alist: Customization
    url-unreserved-chars: URI Encoding

** EXAMPLE
#+Begin_SRC elisp
(defun get-url-content (url)
  "simplily get content from url"
  (let ((ret nil)
;	(url-proxy-services '(("http" . "localhost:8888")))
	(url-request-extra-headers 
	  '(("Content-Type" . "application/json; charset=utf-8")
	    ("X-Requested-With" . "XMLHttpRequest")
	    ("User-Agent" . " Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.75 Safari/537.1")
	    ("Referer" . "http://www.simsimi.com/talk.htm")
	    )
	))
    (with-current-buffer
      (url-retrieve-synchronously  url) 
;      (setq status url-http-response-status)
      (goto-char (point-min))
      (if  (search-forward-regexp "{" nil t)
	  (setq ret (decode-coding-string (substring (car (split-string (buffer-substring (point) (point-max)) "," )) 12 -1) 'utf-8)
		)
;	  (message (buffer-substring (point-min) (point-max)))
	(message "invalid request")
	)
      )
    ret
    )
 )

(defun coffee ()
   "Submit a BREW request to an RFC2324-compliant coffee device"
   (interactive)
   (require 'url)
   (let* ((additions-list
           (append coffee-milk-types
                   coffee-syrup-types
                   coffee-sweetener-types
                   coffee-alcohol-types))
          (additions-string
           (mapconcat #'identity additions-list ","))
          (url (coffee-url))
          (url-request-method "BREW")
          (url-request-extra-headers
           `(("Content-type"     . "message-coffeepot")
             ("Accept-Additions" . ,additions-string)))         
          (url-request-data "START"))
     (run-hooks 'coffee-brew-hook)
     (url-retrieve url)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (let ((url-request-method        "POST")
	      (url-request-extra-headers `(("Content-Type" . "application/x-www-form-urlencoded")))
	      (url-request-data          "field1=Hello&field2=from&field3=Emacs"))
	  (with-current-buffer (url-retrieve-synchronously url)
            (buffer-string)))
#+END_SRC
* 翻译
#+BEGIN_SRC elisp
;; This buffer is for notes you don't want to save, and for Lisp evaluation.
;; If you want to create a file, visit that file with C-x C-f,
;; then enter the text in that file's own buffer.
(defvar bd-url (concat 
	      "http://openapi.baidu.com/public/2.0/bmt/translate?"
	      "client_id=ganHbvW7N4T6jEQ98K0ykXia"
	      "&from=auto&to=auto"))
(setq str "您")
(defun baidu-translate(str)
  (let ((url-request-method "GET")
	buffer
	result)
    (setq buffer (url-retrieve-synchronously (url-generic-parse-url (concat bd-url (url-encode-url (format "&q=%s" str))))))
;    (switch-to-buffer buffer)
    (with-current-buffer buffer
      (goto-char (point-min))
      (re-search-forward "^$")
      (forward-char)
      (setq result (buffer-substring  (point) (point-max))))
    result))
		 


(baidu-translate "你")
"{\"from\":\"zh\",\"to\":\"en\",\"trans_result\":[{\"src\":\"\\u4f60\",\"dst\":\"You\"}]}"


(setq result 
      (json-read-from-string (baidu-translate "你是谁")))

(assoc 'trans_result  result)
(trans_result . [((dst . "Who is it") (src . "你是谁"))])

#+END_SRC       
       
* 代码

#+begin_src language
(buffer-name) ;;function buffer-name return the buffer's name
(buffer-file-name);;return the full path of file
;;C-x C-e runs the command eval-last-sexp, and echoes the result in the minibuffer
;;C-u C-x C-e echoes the result in the current buffer
(current-buffer);;fuction current-buffer retuns the current-buffer
(other-buffer);;
(switch-to-buffer (other-buffer));;switch to the other buffer,C-x b 
（set-buffer);;
;;;;;;;;;;;;;;;;;;;;;;
;;location in the buffer
(buffer-size);;function returns the size of current buffer
(point);;return the current point of the buffer
(point-min)
(point-max)

;;;;;;;;;;;;;;;;;;;;;;
;;defin a function
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven"
  (* 7 number))    ;;C-x C-e load the function
(multiply-by-seven 3)    ;;3*7
;;C-h f (describe-function) multiply-by-seven can echo relative docs in a "help" buffer

;;make a fuction interactive
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven"
  (interactive "p")
  (message "The result is %d" (* 7 number)))
;;use C-u 8  give a parameter 8 and M-x multiply-by-seven then return 56
;;OR M-8 M-x multiply-by-seven 
;;;;;;;;;;;;;;;;;;;;;;
;;interactive options
;;"p" numeric prefix argument
;;"r" point and mark
;;"b"　一个已经存在的缓冲区的名字
;;"f“　一个已经存在的文件的名字
(forword-sentence);; M-e
(let ((var1 'hello)
      (var2 'world))
  (message "%s %s\n" var1 var2))
(message "hello world")
;;;;;;;;;;;;;;;;;;;;;;
(save-excursion
	body ...);;将位点和标记的当前位置保存起来。并当特殊表主体代码解释器执行完毕之后恢复原来位置
(set-mark-command);;C-SPC make mark
(exchange-point-and-mark);;C-x C-x

;;C-h f 查看函数文档
;;Ｃ-h v　查看变量文档
;;find-tags 查看函数定义
;;M-.  查看函数定义
(beginning-of-buffer) ;;C-<
(defun simplified-begnning-of-buffer ()
  ""
  (interactive)
  (push-mark)
  (goto-char (point-min)))

(describe-function);;C-h f
(describe-variable);;C-h v

(defun mark-whole-buffer ()
  ""
  (interactive)
  (push-mark)
  (push-mark (point-max))
  (goto-char (point-min)))

(defun append-to-buffer (buffer start end)
   ""
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
     (save-excursion
        (set-buffer (get-buffer-create buffer))
        (insert-buffer-substring oldbuf start end))))

(defun copy-to-buffer (buffer start end)
   ""
   (interactive "BCopy to buffer: \nr")
   (let ((oldbuf (current-buffer)))
      (save-excursion
         (set-buffer (get-buffer-create buffer))
         (erase-buffer)
         (save-excursion
           (insert-buffer-substring oldbuf start end)))))

(defun insert-buffer (buffer)
  ""
  (interactive "*bInsert buffer: ")
  (or (bufferp buffer)
      (setq buffer (get-buffer buffer)))
   (let (start end newmark)
     (save-excursion
       (save-excursion
         (set-buffer buffer)
         (setq start (point-min) end (point-max)))
     (insert-buffer-substring buffer start end)
     (setq newmark (point)))
     (push-mark newmark)))
#+end_src

* Footnotes

[fn:1] http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html

